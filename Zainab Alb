import discord
from discord.ext import commands, tasks
import json
import random
from datetime import datetime, timedelta
from discord.ui import Button, View
import os
import asyncio
from flask import Flask
from threading import Thread

app = Flask('')

@app.route('/')
def home():
    return "Ø£Ù†Ø§ Ù…ÙˆØ¬ÙˆØ¯Ø© ÙŠØ§ ØºÙŠÙ…! â˜ï¸"

def run():
    app.run(host='0.0.0.0', port=8080)

def keep_alive():
    t = Thread(target=run)
    t.start()
# Bot setup
intents = discord.Intents.all()
bot = commands.Bot(command_prefix='!', intents=intents)

# --- Constants ---
# Ù‚Ù… Ø¨Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø¨Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„ØµØ­ÙŠØ­Ø© ÙÙŠ Ø³ÙŠØ±ÙØ±Ùƒ
SUPREME_CLOUD_ROLE_ID = 1388676960846090311
GHAIM_ROLE_ID = 1388676960846090311
BANK_CHANNEL_ID = 123456789012345678 # Ø§Ø³ØªØ¨Ø¯Ù„ Ù‡Ø°Ø§ Ø¨Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„ØµØ­ÙŠØ­ Ù„Ù„Ù‚Ù†Ø§Ø©

# --- Settings ---
DATA_FILE = 'data.json'
STOCK_MARKET_FILE = 'stock_market.json' # Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø¨ÙˆØ±ØµØ©
LOG_FILE = "log.json"
DEFAULT_COOLDOWN = 300  # 5 Ø¯Ù‚Ø§Ø¦Ù‚
PROTECTION_COST_PER_HOUR = 1000
MIN_BALANCE_FOR_THEFT = 10000
MAX_STEALS_PER_DAY = 3

# --- Stock Market Settings ---
INITIAL_STOCK_PRICE = 10.0
INITIAL_SHARES = 1000
ACTIVITY_TRACKER = {} # Ù„ØªØªØ¨Ø¹ Ù†Ø´Ø§Ø· Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ù…Ø¤Ù‚ØªØ§Ù‹

# --- Roulette Settings ---
PRIZES = [10, 100, 1000, 10000, 100000]
WEIGHTS = [70, 20, 7, 2.9, 0.1]

# --- Runtime Data Storage ---
protected_users = {}
thief_steal_count = {}
pending_marriages = {}
banned_users = set()

# --- Data File Initialization ---
for file_path in [DATA_FILE, STOCK_MARKET_FILE, LOG_FILE]:
    if not os.path.exists(file_path):
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump({} if file_path != LOG_FILE else [], f)

# =============================================================================
# DATA MANAGEMENT FUNCTIONS (Main & Stock)
# =============================================================================

# -- Main Data --
def load_data():
    with open(DATA_FILE, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_data(data):
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

# ... (Ø¬Ù…ÙŠØ¹ Ø¯ÙˆØ§Ù„ get_balance, add_balance, etc. ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ) ...
def get_user(data, user_id):
    uid = str(user_id)
    if uid not in data:
        data[uid] = {
            'balance': 0, 'married_to': None, 'mahr': 0,
            'last_used': {}, 'items': {}
        }
    return data[uid]

def get_balance(user_id):
    data = load_data()
    return get_user(data, user_id)['balance']

def add_balance(user_id, amount):
    data = load_data()
    user = get_user(data, user_id)
    user['balance'] += amount
    save_data(data)

def subtract_balance(user_id, amount):
    data = load_data()
    user = get_user(data, user_id)
    user['balance'] = max(0, user['balance'] - amount)
    save_data(data)

# -- Stock Market Data --
def load_stock_data():
    with open(STOCK_MARKET_FILE, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_stock_data(data):
    with open(STOCK_MARKET_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

def ensure_member_in_market(stock_data, member_id):
    """ÙŠØ¶Ù…Ù† Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ø¹Ø¶Ùˆ ÙÙŠ Ø§Ù„Ø¨ÙˆØ±ØµØ©"""
    mid = str(member_id)
    if "members" not in stock_data:
        stock_data["members"] = {}
    if mid not in stock_data["members"]:
        stock_data["members"][mid] = {
            "price": INITIAL_STOCK_PRICE,
            "shares": INITIAL_SHARES,
            "history": [(datetime.utcnow().isoformat(), INITIAL_STOCK_PRICE)],
            "last_activity": datetime.utcnow().isoformat()
        }
        print(f"Ø£ÙØ¯Ø±Ø¬ Ø§Ù„Ø¹Ø¶Ùˆ {mid} ÙÙŠ Ø§Ù„Ø¨ÙˆØ±ØµØ© Ø¨Ø³Ø¹Ø± {INITIAL_STOCK_PRICE}.")
    return stock_data

# =============================================================================
# BOT EVENTS & BACKGROUND TASKS
# =============================================================================

@bot.event
async def on_ready():
    print(f"âœ… Bot is ready. Logged in as {bot.user}")
    update_stock_prices.start() # Ø¨Ø¯Ø¡ Ù…Ù‡Ù…Ø© ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø±

@bot.event
async def on_message(message):
    if message.author.bot:
        return
    
    # ØªØªØ¨Ø¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù„ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø§Ù„Ø³Ù‡Ù…
    mid = str(message.author.id)
    ACTIVITY_TRACKER.setdefault(mid, {"messages": 0, "reactions": 0})
    ACTIVITY_TRACKER[mid]["messages"] += 1
    
    await bot.process_commands(message)

@bot.event
async def on_reaction_add(reaction, user):
    if user.bot or reaction.message.author.bot or user.id == reaction.message.author.id:
        return
    
    # ØªØªØ¨Ø¹ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©
    mid = str(reaction.message.author.id)
    ACTIVITY_TRACKER.setdefault(mid, {"messages": 0, "reactions": 0})
    ACTIVITY_TRACKER[mid]["reactions"] += 1

@tasks.loop(minutes=10)
async def update_stock_prices():
    """Ù…Ù‡Ù…Ø© ØªØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ© Ù„ØªØ­Ø¯ÙŠØ« Ø£Ø³Ø¹Ø§Ø± Ø£Ø³Ù‡Ù… Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡"""
    await bot.wait_until_ready()
    stock_data = load_stock_data()
    
    # Ø¥Ø¯Ø±Ø§Ø¬ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙˆÙ†ÙˆØ§ Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ†
    for guild in bot.guilds:
        for member in guild.members:
            if not member.bot:
                stock_data = ensure_member_in_market(stock_data, member.id)

    # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø´Ø§Ø·
    for user_id, activity in ACTIVITY_TRACKER.items():
        if user_id in stock_data["members"]:
            member_stock = stock_data["members"][user_id]
            price = member_stock["price"]
            
            # Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¨Ø³ÙŠØ·Ø© Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø¹Ø±
            price_increase_factor = (activity["messages"] * 0.005) + (activity["reactions"] * 0.02)
            new_price = price + price_increase_factor
            
            member_stock["price"] = new_price
            member_stock["last_activity"] = datetime.utcnow().isoformat()
            
            # Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø³Ø¬Ù„ Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠ (Ù†Ø­ØªÙØ¸ Ø¨Ø¢Ø®Ø± 30 ØªØ­Ø¯ÙŠØ«Ù‹Ø§)
            member_stock["history"].append((datetime.utcnow().isoformat(), new_price))
            member_stock["history"] = member_stock["history"][-30:]

    ACTIVITY_TRACKER.clear() # ØªÙØ±ÙŠØº Ø§Ù„Ù…ØªØªØ¨Ø¹ Ù„Ù„Ø¯ÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©

    # ØªØ·Ø¨ÙŠÙ‚ Ø¹Ø§Ù…Ù„ Ø§Ù„Ø®Ù…ÙˆÙ„
    for user_id, member_stock in stock_data.get("members", {}).items():
        last_active = datetime.fromisoformat(member_stock["last_activity"])
        if datetime.utcnow() - last_active > timedelta(days=3):
             # Ø®ÙØ¶ Ø§Ù„Ø³Ø¹Ø± Ø¨Ù†Ø³Ø¨Ø© 1% Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø®Ù…ÙˆÙ„
            member_stock["price"] *= 0.99
            
    save_stock_data(stock_data)
    print(f"[{datetime.now()}] ØªÙ… ØªØ­Ø¯ÙŠØ« Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø¨ÙˆØ±ØµØ©.")

# =============================================================================
# STOCK MARKET COMMANDS (Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØ±ØµØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©)
# =============================================================================

@bot.command(aliases=["Ø¨ÙˆØ±ØµØ©"])
async def Ø³ÙˆÙ‚_Ø§Ù„Ø£Ø³Ù‡Ù…(ctx):
    """ÙŠØ¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø£ØºÙ„Ù‰ Ø§Ù„Ø£Ø³Ù‡Ù… ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±"""
    stock_data = load_stock_data()
    if not stock_data.get("members"):
        return await ctx.send("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ù‡Ù… ÙÙŠ Ø§Ù„Ø¨ÙˆØ±ØµØ© Ø¨Ø¹Ø¯.")

    # ÙØ±Ø² Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø­Ø³Ø¨ Ø³Ø¹Ø± Ø§Ù„Ø³Ù‡Ù…
    sorted_stocks = sorted(
        stock_data["members"].items(),
        key=lambda item: item[1]["price"],
        reverse=True
    )[:10]

    embed = discord.Embed(
        title="ğŸ† Ø¨ÙˆØ±ØµØ© Ø§Ù„Ø³ÙŠØ±ÙØ± - Ø£ØºÙ„Ù‰ 10 Ø£Ø³Ù‡Ù…",
        description="Ù‚ÙŠÙ…Ø© Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ ØªØ±ØªÙØ¹ ÙˆØªÙ†Ø®ÙØ¶ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ØªÙØ§Ø¹Ù„Ù‡Ù…!",
        color=discord.Color.gold()
    )

    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
    for i, (member_id, data) in enumerate(sorted_stocks):
        try:
            member = await ctx.guild.fetch_member(int(member_id))
            member_name = member.display_name
        except discord.NotFound:
            member_name = f"Ø¹Ø¶Ùˆ ØºØ§Ø¯Ø± ({member_id[-4:]})"
        
        rank = medals[i] if i < 3 else f"**#{i+1}**"
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØºÙŠØ± ÙÙŠ Ø¢Ø®Ø± 24 Ø³Ø§Ø¹Ø©
        history = data.get("history", [])
        price_now = data["price"]
        price_24h_ago = history[0][1] if history else price_now
        change_percent = ((price_now - price_24h_ago) / price_24h_ago) * 100 if price_24h_ago > 0 else 0
        change_emoji = "ğŸ“ˆ" if change_percent >= 0 else "ğŸ“‰"

        embed.add_field(
            name=f"{rank} {member_name}",
            value=f"> **Ø§Ù„Ø³Ø¹Ø±:** `{price_now:,.2f}` ØºÙŠÙ…Ø©\n> **Ø§Ù„ØªØºÙŠØ±:** `{change_percent:+.2f}%` {change_emoji}",
            inline=False
        )
    
    embed.set_footer(text="Ø§Ø³ØªØ®Ø¯Ù… !Ø³Ø¹Ø±_Ø³Ù‡Ù… @Ø¹Ø¶Ùˆ Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„ØªÙØ§ØµÙŠÙ„")
    await ctx.send(embed=embed)

@bot.command()
async def Ø³Ø¹Ø±_Ø³Ù‡Ù…(ctx, member: discord.Member):
    """ÙŠØ¹Ø±Ø¶ Ø³Ø¹Ø± Ø³Ù‡Ù… Ø¹Ø¶Ùˆ Ù…Ø¹ÙŠÙ†"""
    if member.bot:
        return await ctx.send("Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù„Ù„Ø±ÙˆØ¨ÙˆØªØ§Øª Ø£Ù† ØªÙƒÙˆÙ† Ø£Ø³Ù‡Ù…Ù‹Ø§.")

    stock_data = load_stock_data()
    stock_data = ensure_member_in_market(stock_data, member.id)
    member_stock = stock_data["members"][str(member.id)]

    price = member_stock["price"]
    shares = member_stock["shares"]

    embed = discord.Embed(
        title=f"Ø³Ø¹Ø± Ø³Ù‡Ù… {member.display_name}",
        color=member.color
    )
    embed.set_thumbnail(url=member.display_avatar.url)
    embed.add_field(name="Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ø³Ù‡Ù… Ø§Ù„ÙˆØ§Ø­Ø¯", value=f"`{price:,.2f}` ØºÙŠÙ…Ø©", inline=True)
    embed.add_field(name="Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø³Ù‡Ù… Ø§Ù„Ù…ØµØ¯Ø±Ø©", value=f"`{shares:,}` Ø³Ù‡Ù…", inline=True)
    embed.set_footer(text="Ø§Ø³ØªØ®Ø¯Ù… !Ø´Ø±Ø§Ø¡_Ø³Ù‡Ù… Ùˆ !Ø¨ÙŠØ¹_Ø³Ù‡Ù… Ù„Ù„ØªØ¯Ø§ÙˆÙ„")
    await ctx.send(embed=embed)

@bot.command()
async def Ø´Ø±Ø§Ø¡_Ø³Ù‡Ù…(ctx, member: discord.Member, quantity: int):
    """Ù„Ø´Ø±Ø§Ø¡ Ø£Ø³Ù‡Ù… Ø¹Ø¶Ùˆ Ù…Ø¹ÙŠÙ†"""
    buyer = ctx.author
    if member.id == buyer.id:
        return await ctx.send("Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù‡Ù… ÙÙŠ Ù†ÙØ³Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±.")
    if quantity <= 0:
        return await ctx.send("ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„ÙƒÙ…ÙŠØ© Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±.")

    stock_data = load_stock_data()
    stock_data = ensure_member_in_market(stock_data, member.id)
    member_stock = stock_data["members"][str(member.id)]
    
    price_per_share = member_stock["price"]
    total_cost = price_per_share * quantity

    buyer_balance = get_balance(buyer.id)
    if buyer_balance < total_cost:
        return await ctx.send(f"Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙŠ. Ø§Ù„ØªÙƒÙ„ÙØ©: `{total_cost:,.2f}` ØºÙŠÙ…Ø©.")

    # ØªÙ†ÙÙŠØ° Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
    subtract_balance(buyer.id, total_cost)
    
    # ØªØ­Ø¯ÙŠØ« Ù…Ø­ÙØ¸Ø© Ø§Ù„Ù…Ø´ØªØ±ÙŠ
    stock_data.setdefault("portfolios", {}).setdefault(str(buyer.id), {})
    stock_data["portfolios"][str(buyer.id)][str(member.id)] = stock_data["portfolios"][str(buyer.id)].get(str(member.id), 0) + quantity

    # Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ù‡Ù… Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù„Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
    member_stock["shares"] += quantity
    # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø¹Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø·Ù„Ø¨
    member_stock["price"] *= (1 + (quantity / member_stock["shares"]) * 0.05) 

    save_stock_data(stock_data)
    await ctx.send(f"âœ… ØªÙ… Ø´Ø±Ø§Ø¡ {quantity} Ø³Ù‡Ù… Ù…Ù† {member.mention} Ø¨Ù†Ø¬Ø§Ø­ Ù…Ù‚Ø§Ø¨Ù„ `{total_cost:,.2f}` ØºÙŠÙ…Ø©.")

@bot.command()
async def Ø¨ÙŠØ¹_Ø³Ù‡Ù…(ctx, member: discord.Member, quantity: int):
    """Ù„Ø¨ÙŠØ¹ Ø£Ø³Ù‡Ù… ØªÙ…Ù„ÙƒÙ‡Ø§ ÙÙŠ Ø¹Ø¶Ùˆ"""
    seller = ctx.author
    if quantity <= 0:
        return await ctx.send("ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„ÙƒÙ…ÙŠØ© Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±.")

    stock_data = load_stock_data()
    portfolio = stock_data.get("portfolios", {}).get(str(seller.id), {})
    
    owned_shares = portfolio.get(str(member.id), 0)
    if owned_shares < quantity:
        return await ctx.send(f"Ø£Ù†Øª ØªÙ…Ù„Ùƒ ÙÙ‚Ø· {owned_shares} Ø³Ù‡Ù… ÙÙŠ {member.mention}.")

    member_stock = stock_data["members"][str(member.id)]
    price_per_share = member_stock["price"]
    total_earnings = price_per_share * quantity

    # ØªÙ†ÙÙŠØ° Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
    add_balance(seller.id, total_earnings)
    
    # ØªØ­Ø¯ÙŠØ« Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹
    portfolio[str(member.id)] -= quantity
    if portfolio[str(member.id)] <= 0:
        del portfolio[str(member.id)]
    
    # Ø®ÙØ¶ Ø§Ù„Ø³Ø¹Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø¹Ø±Ø¶
    member_stock["price"] *= (1 - (quantity / member_stock["shares"]) * 0.05)

    save_stock_data(stock_data)
    await ctx.send(f"âœ… ØªÙ… Ø¨ÙŠØ¹ {quantity} Ø³Ù‡Ù… Ù…Ù† {member.mention} Ø¨Ù†Ø¬Ø§Ø­ ÙˆØ±Ø¨Ø­Øª `{total_earnings:,.2f}` ØºÙŠÙ…Ø©.")

@bot.command(aliases=["Ø§Ø³ØªØ«Ù…Ø§Ø±Ø§ØªÙŠ"])
async def Ù…Ø­ÙØ¸ØªÙŠ(ctx, member: discord.Member = None):
    """Ù„Ø¹Ø±Ø¶ Ù…Ø­ÙØ¸ØªÙƒ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠØ© Ø£Ùˆ Ù…Ø­ÙØ¸Ø© Ø¹Ø¶Ùˆ Ø¢Ø®Ø±"""
    target = member or ctx.author
    
    stock_data = load_stock_data()
    portfolio = stock_data.get("portfolios", {}).get(str(target.id), {})

    if not portfolio:
        return await ctx.send(f"Ù…Ø­ÙØ¸Ø© {target.mention} Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠØ© ÙØ§Ø±ØºØ©.")
    
    embed = discord.Embed(
        title=f"ğŸ’¼ Ù…Ø­ÙØ¸Ø© {target.display_name} Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠØ©",
        color=target.color
    )
    total_value = 0.0
    
    for member_id, quantity in portfolio.items():
        try:
            stock_owner = await ctx.guild.fetch_member(int(member_id))
            owner_name = stock_owner.display_name
            current_price = stock_data.get("members", {}).get(member_id, {"price": 0})["price"]
            value = current_price * quantity
            total_value += value
            
            embed.add_field(
                name=f"Ø£Ø³Ù‡Ù… ÙÙŠ {owner_name}",
                value=f"> **Ø§Ù„ÙƒÙ…ÙŠØ©:** `{quantity}`\n> **Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:** `{value:,.2f}` ØºÙŠÙ…Ø©",
                inline=False
            )
        except discord.NotFound:
            continue
    
    embed.set_footer(text=f"Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø­ÙØ¸Ø©: {total_value:,.2f} ØºÙŠÙ…Ø©")
    await ctx.send(embed=embed)

SUPREME_CLOUD_ROLE_ID = 1388676960846090311
GHAIM_ROLE_ID = 1388676960846090311
BANK_CHANNEL_ID = 123456789012345678 # Ø§Ø³ØªØ¨Ø¯Ù„ Ù‡Ø°Ø§ Ø¨Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„ØµØ­ÙŠØ­ Ù„Ù„Ù‚Ù†Ø§Ø©

# --- Settings ---
DATA_FILE = 'data.json'
LOG_FILE = "log.json"
DEFAULT_COOLDOWN = 300  # 5 Ø¯Ù‚Ø§Ø¦Ù‚
PROTECTION_COST_PER_HOUR = 1000
MIN_BALANCE_FOR_THEFT = 10000
MAX_STEALS_PER_DAY = 3

# --- Roulette Settings ---
PRIZES = [10, 100, 1000, 10000, 100000]
WEIGHTS = [70, 20, 7, 2.9, 0.1]

# --- Runtime Data Storage ---
protected_users = {}
thief_steal_count = {}
pending_marriages = {}
banned_users = set()

# --- Data File Initialization ---
if not os.path.exists(DATA_FILE):
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump({}, f)

if not os.path.exists(LOG_FILE):
    with open(LOG_FILE, 'w', encoding='utf-8') as f:
        json.dump([], f)

def load_data():
    with open(DATA_FILE, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_data(data):
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

def get_user(data, user_id):
    uid = str(user_id)
    if uid not in data:
        data[uid] = {
            'balance': 0, 'married_to': None, 'mahr': 0,
            'last_used': {}, 'items': {}
        }
    if 'items' not in data[uid]:
        data[uid]['items'] = {}
    return data[uid]

def get_balance(user_id):
    data = load_data()
    return get_user(data, user_id)['balance']

def set_balance(user_id, amount):
    data = load_data()
    user = get_user(data, user_id)
    user['balance'] = max(0, amount)
    save_data(data)

def add_balance(user_id, amount):
    current_balance = get_balance(user_id)
    set_balance(user_id, current_balance + amount)

def subtract_balance(user_id, amount):
    current_balance = get_balance(user_id)
    set_balance(user_id, current_balance - amount)

def get_items(user_id):
    data = load_data()
    return get_user(data, user_id).get('items', {})

def add_item(user_id, item_name, quantity=1):
    data = load_data()
    user = get_user(data, user_id)
    user['items'][item_name] = user['items'].get(item_name, 0) + quantity
    save_data(data)

def remove_item(user_id, item_name, quantity=1):
    data = load_data()
    user = get_user(data, user_id)
    if item_name not in user['items'] or user['items'][item_name] < quantity:
        return False
    user['items'][item_name] -= quantity
    if user['items'][item_name] <= 0:
        del user['items'][item_name]
    save_data(data)
    return True

def load_log():
    with open(LOG_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def save_log(logs):
    with open(LOG_FILE, "w", encoding="utf-8") as f:
        json.dump(logs, f, indent=4, ensure_ascii=False)

def add_log_entry(executor_id, action, target):
    logs = load_log()
    logs.append({
        "executor": str(executor_id), "action": action, "target": str(target),
        "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    })
    save_log(logs)

def can_steal(thief_id):
    today = datetime.now().date()
    rec = thief_steal_count.get(thief_id, {'count': 0, 'date': today})
    if rec['date'] != today:
        rec = {'count': 0, 'date': today}
    thief_steal_count[thief_id] = rec
    return rec['count'] < MAX_STEALS_PER_DAY

def add_steal(thief_id):
    thief_steal_count.setdefault(thief_id, {'count': 0, 'date': datetime.now().date()})['count'] += 1

def is_protected(user_id):
    exp = protected_users.get(user_id)
    if exp and datetime.now() < exp:
        return True
    protected_users.pop(user_id, None)
    return False

store_items = {
    "Ø¨Ø®Ø´ÙŠØ´_ÙƒØ¨ÙŠØ±": 10000, "ÙˆØ±Ø¯Ø©": 2000, "Ø³ÙŠØ§Ø±Ø©": 30000, "Ø°Ù‡Ø¨": 15000,
    "Ù…Ù„Ø¹Ø¨": 50000, "Ø·ÙŠØ§Ø±Ø©": 100000, "Ù‚Ø·Ø§Ø±": 40000
}

@bot.event
async def on_ready():
    print(f"âœ… Bot is ready. Logged in as {bot.user}")

@bot.event
async def on_command_completion(ctx):
    if ctx.command.name in ['Ù…Ù†Ø¹', 'ÙÙƒ_Ø§Ù„Ù…Ù†Ø¹', 'ØªØµÙÙŠØ±', 'Ø§Ø¹Ø·Ø§Ø¡']:
        target_member = ctx.args[1] if len(ctx.args) > 1 else "N/A"
        add_log_entry(ctx.author.id, ctx.command.name, target_member)

@bot.check
async def globally_block_banned(ctx):
    if ctx.author.id in banned_users:
        await ctx.send(f"âŒ Ø¹Ø°Ø±Ø§Ù‹ {ctx.author.mention}ØŒ Ø£Ù†Øª Ù…Ù…Ù†ÙˆØ¹ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª.")
        return False
    return True
# ... (Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±)
# The rest of the original code (economy, marriage, admin commands) goes here.
# I will collapse it for brevity, but it should be included in the final file.
# --- [COLLAPSED ORIGINAL CODE: ECONOMY, MARRIAGE, ADMIN, UTILITY COMMANDS] ---
@bot.command()
@commands.cooldown(1, 900, commands.BucketType.user)  # 15 Ø¯Ù‚ÙŠÙ‚Ø©
async def Ø±Ø§ØªØ¨(ctx):
    amount = random.randint(900, 900000)
    add_balance(ctx.author.id, amount)
    await ctx.send(f'ğŸ’¸ ØµØ±ÙÙ†Ø§ Ù„Ùƒ {amount} ØºÙŠÙ…Ø©! Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø¢Ù†: {get_balance(ctx.author.id)}')

# And so on for all other commands...
# I'll paste the full code again to be safe.


# =============================================================================
# The rest of your code. This is a complete file.
# =============================================================================

# ... [Previous Data Management and Stock Market code] ...

# =============================================================================
# GAME COMMANDS
# =============================================================================



class RPSView(View):
    def __init__(self, player):
        super().__init__(timeout=60)
        self.player = player

    async def interaction_check(self, interaction):
        return interaction.user == self.player

    async def end_game(self, interaction, choice):
        choices = {'Rock': 'ğŸª¨', 'Paper': 'ğŸ“„', 'Scissors': 'âœ‚ï¸'}
        bot_choice_en = random.choice(list(choices.keys()))
        bot_choice_ar = choices[bot_choice_en]
        result_ar = ''
        if choice == bot_choice_en:
            result_ar = 'ØªØ¹Ø§Ø¯Ù„!'
        elif (choice, bot_choice_en) in [('Rock','Scissors'),('Paper','Rock'),('Scissors','Paper')]:
            add_balance(self.player.id, 5000)
            result_ar = 'ÙØ²Øª ÙˆØ±Ø¨Ø­Øª 5000 ØºÙŠÙ…Ø©!'
        else:
            result_ar = 'Ø®Ø³Ø±Øª!'
        for btn in self.children: btn.disabled = True
        await interaction.response.edit_message(view=self)
        embed = discord.Embed(title='Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©', description=f"Ø§Ø®ØªÙŠØ§Ø±Ùƒ: {choices[choice]}\nØ§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¨ÙˆØª: {bot_choice_ar}\n\n**{result_ar}**")
        await interaction.followup.send(embed=embed)

    @discord.ui.button(label='ğŸª¨', style=discord.ButtonStyle.primary)
    async def rock(self, i, _): await self.end_game(i, 'Rock')
    @discord.ui.button(label='ğŸ“„', style=discord.ButtonStyle.success)
    async def paper(self, i, _): await self.end_game(i, 'Paper')
    @discord.ui.button(label='âœ‚ï¸', style=discord.ButtonStyle.danger)
    async def scissors(self, i, _): await self.end_game(i, 'Scissors')

@bot.command(name="Ù„Ø¹Ø¨Ø©", aliases=['game'])
@commands.cooldown(1, DEFAULT_COOLDOWN, commands.BucketType.user)
async def play_game(ctx):
    await ctx.send('Ø§Ø®ØªØ± Ù„Ø¹Ø¨ØªÙƒ:', view=RPSView(ctx.author))

@bot.command()
@commands.cooldown(1, DEFAULT_COOLDOWN, commands.BucketType.user) # 5 Ø¯Ù‚Ø§Ø¦Ù‚
async def Ø¨Ø®Ø´ÙŠØ´(ctx):
    tip = random.randint(50, 200)
    add_balance(ctx.author.id, tip)
    await ctx.send(f"ğŸ’¸ {ctx.author.mention} Ø§Ø³ØªÙ„Ù… Ø¨Ø®Ø´ÙŠØ´ Ù„Ø·ÙŠÙ ÙˆÙ‚Ø¯Ø±Ù‡ {tip} ØºÙŠÙ…Ø©!\nØ´ÙƒÙ„Ùƒ Ù…Ø­Ø¨ÙˆØ¨ Ø§Ù„ÙŠÙˆÙ…! ğŸŒ·")

@bot.command()
async def ØªØ­ÙˆÙŠÙ„(ctx, Ø§Ù„Ø¹Ø¶Ùˆ: discord.Member, Ø§Ù„Ù…Ø¨Ù„Øº: int):
    Ø§Ù„Ù…Ø±Ø³Ù„ = ctx.author
    if Ø§Ù„Ø¹Ø¶Ùˆ.id == Ø§Ù„Ù…Ø±Ø³Ù„.id:
        return await ctx.send("ğŸš« ÙˆØ´ Ø§Ù„Ø³Ø§Ù„ÙØ©ØŸ ØªØ­ÙˆÙ‘Ù„ Ù„Ù†ÙØ³ÙƒØŸ ÙˆØ´ Ø°Ø§ Ø§Ù„Ø¹Ø¨Ø«ØŸ ğŸ˜‚")
    if Ø§Ù„Ù…Ø¨Ù„Øº <= 0:
        return await ctx.send("ğŸ”º ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ø¨Ù„Øº Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±.")
    Ø±ØµÙŠØ¯_Ø§Ù„Ù…Ø±Ø³Ù„ = get_balance(Ø§Ù„Ù…Ø±Ø³Ù„.id)
    if Ø±ØµÙŠØ¯_Ø§Ù„Ù…Ø±Ø³Ù„ < Ø§Ù„Ù…Ø¨Ù„Øº:
        return await ctx.send("Ø¨Ø³ Ø¨Ø³ ÙŠØ§Ù„ØºÙ†ÙŠØŒ Ù…Ø§ Ø¹Ù†Ø¯Ùƒ ÙƒÙ„ Ù‡Ø§Ù„ØºÙŠÙ…Ø§Øª Ø¨Ø±ØµÙŠØ¯Ùƒ ğŸ¤£")
    subtract_balance(Ø§Ù„Ù…Ø±Ø³Ù„.id, Ø§Ù„Ù…Ø¨Ù„Øº)
    add_balance(Ø§Ù„Ø¹Ø¶Ùˆ.id, Ø§Ù„Ù…Ø¨Ù„Øº)
    await ctx.send(f"âœ… ØªÙ… ØªØ­ÙˆÙŠÙ„ {Ø§Ù„Ù…Ø¨Ù„Øº} ØºÙŠÙ…Ø© Ù„Ù€ {Ø§Ù„Ø¹Ø¶Ùˆ.mention} Ø¨Ù†Ø¬Ø§Ø­!")

@bot.command()
async def Ø±ØµÙŠØ¯ÙŠ(ctx, member: discord.Member = None):
    target = member or ctx.author
    balance = get_balance(target.id)
    if member:
        await ctx.send(f'ğŸ’° Ø±ØµÙŠØ¯ {target.mention} Ù‡Ùˆ: {balance} ØºÙŠÙ…Ø©.')
    else:
        await ctx.send(f'ğŸ’° Ø±ØµÙŠØ¯Ùƒ: {balance} ØºÙŠÙ…Ø©.')

@bot.command()
@commands.cooldown(1, DEFAULT_COOLDOWN, commands.BucketType.user) # 5 Ø¯Ù‚Ø§Ø¦Ù‚
async def Ø±ÙˆÙ„ÙŠØª(ctx):
    Ø§Ù„Ø¬Ø§Ø¦Ø²Ø© = random.choices(PRIZES, weights=WEIGHTS, k=1)[0]
    add_balance(ctx.author.id, Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©)
    response = (f"ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! Ù„Ù‚Ø¯ Ø¯Ø±Øª Ø¹Ø¬Ù„Ø© Ø§Ù„Ø­Ø¸ ÙˆÙØ²Øª Ø¨Ù€ **{Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©:,}** ØºÙŠÙ…Ø©! â˜ï¸\n"
                f"Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù‡Ùˆ: **{get_balance(ctx.author.id):,}** ØºÙŠÙ…Ø©.")
    await ctx.send(response)

@bot.command()
@commands.cooldown(1, DEFAULT_COOLDOWN, commands.BucketType.user) # 5 Ø¯Ù‚Ø§Ø¦Ù‚
async def Ø§Ø³ØªØ«Ù…Ø§Ø±(ctx, Ø§Ù„Ù…Ø¨Ù„Øº: int):
    user_id = ctx.author.id
    if Ø§Ù„Ù…Ø¨Ù„Øº <= 0:
        return await ctx.send("ğŸ”º Ù…Ø¨Ù„Øº ØºÙŠØ± ØµØ§Ù„Ø­.")
    if get_balance(user_id) < Ø§Ù„Ù…Ø¨Ù„Øº:
        return await ctx.send("âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙŠ.")
    Ù†Ø³Ø¨Ø©_Ø§Ù„Ø±Ø¨Ø­ = random.uniform(0.8, 1.5)
    Ø§Ù„Ø±Ø¨Ø­ = int(Ø§Ù„Ù…Ø¨Ù„Øº * Ù†Ø³Ø¨Ø©_Ø§Ù„Ø±Ø¨Ø­)
    Ø§Ù„Ø±Ø¨Ø­_Ø§Ù„ØµØ§ÙÙŠ = Ø§Ù„Ø±Ø¨Ø­ - Ø§Ù„Ù…Ø¨Ù„Øº
    add_balance(user_id, Ø§Ù„Ø±Ø¨Ø­_Ø§Ù„ØµØ§ÙÙŠ)
    Ø§Ù„Ø£Ù…Ø§ÙƒÙ† = ["Ø¨ÙˆØ±ØµØ© Ø§Ù„ØºÙŠÙˆÙ… â˜ï¸", "Ø³ÙˆÙ‚ Ø§Ù„Ø¸Ù„Ø§Ù„ ğŸ–¤", "ÙˆØ§Ø¯ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ ğŸ’¹", "Ø´Ø±ÙƒØ© Ø§Ù„ØºÙŠÙ…Ø© Ø§Ù„Ø¹Ø¸Ù…Ù‰ ğŸ¢", "ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„Ù†ÙŠØ§Ø²Ùƒ ğŸš€", "Ø¬Ø²Ø± Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± ğŸï¸"]
    Ø§Ù„Ù…ÙƒØ§Ù† = random.choice(Ø§Ù„Ø£Ù…Ø§ÙƒÙ†)
    await ctx.send(f"ğŸ’¸ {ctx.author.mention} Ø§Ø³ØªØ«Ù…Ø±Øª {Ø§Ù„Ù…Ø¨Ù„Øº} ØºÙŠÙ…Ø© ÙÙŠ **{Ø§Ù„Ù…ÙƒØ§Ù†}**.\nÙˆØ±Ø¬Ø¹Øª Ù„Ùƒ {Ø§Ù„Ø±Ø¨Ø­} ØºÙŠÙ…Ø©!\n(Ø±Ø¨Ø­ ØµØ§ÙÙŠ: {Ø§Ù„Ø±Ø¨Ø­_Ø§Ù„ØµØ§ÙÙŠ} â˜ï¸)")

@bot.command()
@commands.cooldown(1, DEFAULT_COOLDOWN, commands.BucketType.user) # 5 Ø¯Ù‚Ø§Ø¦Ù‚
async def ØªØ¯Ø§ÙˆÙ„(ctx, Ø§Ù„Ù…Ø¨Ù„Øº: int):
    user_id = ctx.author.id
    if Ø§Ù„Ù…Ø¨Ù„Øº <= 0:
        return await ctx.send("ğŸ”º Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø¨Ù…Ø¨Ù„Øº ØµÙØ± Ø£Ùˆ Ø£Ù‚Ù„.")
    if get_balance(user_id) < Ø§Ù„Ù…Ø¨Ù„Øº:
        return await ctx.send("âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙŠ.")
    Ù†Ø³Ø¨Ø©_Ø§Ù„ØªØ¯Ø§ÙˆÙ„ = random.uniform(0.5, 2.0)
    Ø§Ù„Ù†Ø§ØªØ¬ = int(Ø§Ù„Ù…Ø¨Ù„Øº * Ù†Ø³Ø¨Ø©_Ø§Ù„ØªØ¯Ø§ÙˆÙ„)
    Ø§Ù„Ø±Ø¨Ø­_Ø§Ùˆ_Ø§Ù„Ø®Ø³Ø§Ø±Ø© = Ø§Ù„Ù†Ø§ØªØ¬ - Ø§Ù„Ù…Ø¨Ù„Øº
    add_balance(user_id, Ø§Ù„Ø±Ø¨Ø­_Ø§Ùˆ_Ø§Ù„Ø®Ø³Ø§Ø±Ø©)
    Ø§Ù„Ø£Ù…Ø§ÙƒÙ† = ["ÙƒÙˆÙƒØ¨ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ ğŸª", "Ø³ÙˆÙ‚ Ø§Ù„Ø±ÙŠØ§Ø­ ğŸŒªï¸", "Ø¨Ø±Ø¬ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„ÙØ¶ÙŠ ğŸ™ï¸", "Ù…Ø®ØªØ¨Ø± Ø§Ù„Ù…Ø¬Ø§Ø²ÙØ§Øª ğŸ”¬", "Ø¬Ø²ÙŠØ±Ø© Ø§Ù„Ø£Ø³Ù‡Ù… ğŸ–ï¸", "Ù†Ù‚Ø·Ø© Ø§Ù„ØºÙŠÙ…Ø© Ø§Ù„Ø³Ø§Ø®Ù†Ø© â˜ï¸ğŸ”¥"]
    Ø§Ù„Ù…ÙƒØ§Ù† = random.choice(Ø§Ù„Ø£Ù…Ø§ÙƒÙ†)
    msg = f"ğŸ“ˆ ØµÙÙ‚Ø© Ù†Ø§Ø¬Ø­Ø©! Ø±Ø¨Ø­Øª {Ø§Ù„Ø±Ø¨Ø­_Ø§Ùˆ_Ø§Ù„Ø®Ø³Ø§Ø±Ø©} ØºÙŠÙ…Ø© ğŸ’¸" if Ø§Ù„Ø±Ø¨Ø­_Ø§Ùˆ_Ø§Ù„Ø®Ø³Ø§Ø±Ø© >= 0 else f"ğŸ“‰ ØµÙÙ‚Ø© Ø®Ø§Ø³Ø±Ø©! Ø®Ø³Ø±Øª {abs(Ø§Ù„Ø±Ø¨Ø­_Ø§Ùˆ_Ø§Ù„Ø®Ø³Ø§Ø±Ø©)} ØºÙŠÙ…Ø© ğŸ’”"
    await ctx.send(f"ğŸ” {ctx.author.mention} ØªØ¯Ø§ÙˆÙ„Øª Ø¨Ù€ {Ø§Ù„Ù…Ø¨Ù„Øº} ØºÙŠÙ…Ø© ÙÙŠ **{Ø§Ù„Ù…ÙƒØ§Ù†}**.\n{msg}")

@bot.command()
@commands.cooldown(1, DEFAULT_COOLDOWN, commands.BucketType.user) # 5 Ø¯Ù‚Ø§Ø¦Ù‚
async def Ù†Ù‡Ø¨(ctx, Ø§Ù„Ø¹Ø¶Ùˆ: discord.Member):
    if Ø§Ù„Ø¹Ø¶Ùˆ.bot or Ø§Ù„Ø¹Ø¶Ùˆ.id == ctx.author.id:
        return await ctx.send("Ù…Ø§ ØªÙ‚Ø¯Ø± ØªÙ†Ù‡Ø¨ Ø¨ÙˆØª Ø£Ùˆ Ù†ÙØ³Ùƒ.")
    if not can_steal(ctx.author.id):
        return await ctx.send("âŒ ÙˆØµÙ„Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù†Ù‡Ø¨ Ø§Ù„ÙŠÙˆÙ….")
    if is_protected(Ø§Ù„Ø¹Ø¶Ùˆ.id):
        return await ctx.send("ğŸ›¡ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø´Ø®Øµ Ù…Ø­Ù…ÙŠ Ø­Ø§Ù„ÙŠØ§Ù‹.")
    Ø§Ù„Ù…Ø³Ø±ÙˆÙ‚ = get_balance(Ø§Ù„Ø¹Ø¶Ùˆ.id)
    if Ø§Ù„Ù…Ø³Ø±ÙˆÙ‚ < MIN_BALANCE_FOR_THEFT:
        return await ctx.send("ğŸ’¸ Ø§Ù„Ø´Ø®Øµ Ù„Ø§ ÙŠÙ…Ù„Ùƒ Ù…Ø§ ÙŠÙƒÙÙŠ Ù…Ù† Ø§Ù„Ø±ØµÙŠØ¯ Ù„Ù„Ù†Ù‡Ø¨.")
    amount = random.randint(1000, min(10000, Ø§Ù„Ù…Ø³Ø±ÙˆÙ‚ // 2))
    subtract_balance(Ø§Ù„Ø¹Ø¶Ùˆ.id, amount)
    add_balance(ctx.author.id, amount)
    add_steal(ctx.author.id)
    await ctx.send(f"ğŸ’¥ Ù†Ø¬Ø­Øª ÙÙŠ Ù†Ù‡Ø¨ `{amount}` ØºÙŠÙ…Ø© Ù…Ù† {Ø§Ù„Ø¹Ø¶Ùˆ.mention}!")

@bot.command()
async def ØªÙˆØ¨(ctx):
    data = load_data()
    Ø§Ù„ØªØ±ØªÙŠØ¨ = sorted([item for item in data.items() if item[1].get('balance', 0) > 0], key=lambda x: x[1]['balance'], reverse=True)[:10]
    if not Ø§Ù„ØªØ±ØªÙŠØ¨:
        return await ctx.send("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£ØºÙ†ÙŠØ§Ø¡ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± Ø¨Ø¹Ø¯.")
    ÙˆØµÙ = ""
    for i, (uid, info) in enumerate(Ø§Ù„ØªØ±ØªÙŠØ¨, start=1):
        try:
            user = await bot.fetch_user(int(uid))
            ÙˆØµÙ += f"{i}- {user.mention}: `{info['balance']:,}` ØºÙŠÙ…Ø©\n"
        except discord.NotFound:
            ÙˆØµÙ += f"{i}- `Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ({uid})`: `{info['balance']:,}` ØºÙŠÙ…Ø©\n"
    await ctx.send(embed=discord.Embed(title="ğŸ† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ØºÙ†ÙŠØ§Ø¡", description=ÙˆØµÙ, color=discord.Color.gold()))

@bot.command()
async def Ù…ØªØ¬Ø±(ctx):
    desc = "\n".join([f"â€¢ `{item}` - {price:,} ØºÙŠÙ…Ø©" for item, price in store_items.items()])
    desc += "\nâ€¢ `Ø­Ù…Ø§ÙŠØ©` - 1000 ØºÙŠÙ…Ø© Ù„ÙƒÙ„ Ø³Ø§Ø¹Ø© (Ø¹Ø¨Ø± !Ø´Ø±Ø§Ø¡ Ø­Ù…Ø§ÙŠØ©)"
    embed = discord.Embed(title="ğŸ›’ Ø§Ù„Ù…ØªØ¬Ø±", description=desc, color=discord.Color.teal())
    await ctx.send(embed=embed)

@bot.group(name="Ø´Ø±Ø§Ø¡", invoke_without_command=True)
async def Ø´Ø±Ø§Ø¡(ctx, item: str = None, quantity: int = 1):
    if item is None:
        return await ctx.send("Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªØ´ØªØ±ÙŠØŸ\nØ§Ø³ØªØ®Ø¯Ù…: `!Ø´Ø±Ø§Ø¡ [Ø§Ø³Ù… Ø§Ù„Ø¹Ù†ØµØ±]` Ø£Ùˆ `!Ø´Ø±Ø§Ø¡ Ø­Ù…Ø§ÙŠØ© [Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø§Øª]`")
    user_id = str(ctx.author.id)
    found_item = next((key for key in store_items.keys() if key.lower() == item.lower()), None)
    if not found_item:
        return await ctx.send("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù†ØµØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù…ØªØ¬Ø± Ø£Ùˆ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø£Ù…Ø±Ø§Ù‹ ÙØ±Ø¹ÙŠØ§Ù‹ Ù…Ø«Ù„ `!Ø´Ø±Ø§Ø¡ Ø­Ù…Ø§ÙŠØ©`.")
    if quantity < 1:
        return await ctx.send("âŒ Ù„Ø§Ø²Ù… ØªØ´ØªØ±ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ ÙˆØ­Ø¯Ø©.")
    total_price = store_items[found_item] * quantity
    if get_balance(user_id) < total_price:
        return await ctx.send("âŒ Ø±ØµÙŠØ¯Ùƒ Ù…Ø§ ÙŠÙƒÙÙŠ Ù„Ø´Ø±Ø§Ø¡ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©.")
    subtract_balance(user_id, total_price)
    add_item(user_id, found_item, quantity)
    await ctx.send(f"âœ… {ctx.author.mention} ØªÙ… Ø´Ø±Ø§Ø¡ {quantity} Ã— {found_item} Ø¨Ù†Ø¬Ø§Ø­!\nØ±ØµÙŠØ¯Ùƒ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {get_balance(user_id):,} ØºÙŠÙ…Ø©.")

@Ø´Ø±Ø§Ø¡.command(name="Ø­Ù…Ø§ÙŠØ©")
async def purchase_protection(ctx, Ø³Ø§Ø¹Ø§Øª: int = 1):
    if not 1 <= Ø³Ø§Ø¹Ø§Øª <= 7:
        return await ctx.send("Ù…Ø¯Ø© Ø§Ù„Ø­Ù…Ø§ÙŠØ© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø¨ÙŠÙ† Ø³Ø§Ø¹Ø© Ùˆ 7 Ø³Ø§Ø¹Ø§Øª ÙÙ‚Ø·.")
    ØªÙƒÙ„ÙØ© = Ø³Ø§Ø¹Ø§Øª * PROTECTION_COST_PER_HOUR
    if get_balance(ctx.author.id) < ØªÙƒÙ„ÙØ©:
        return await ctx.send(f"Ù…Ø§ Ø¹Ù†Ø¯Ùƒ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙŠ. Ø§Ù„Ø­Ù…Ø§ÙŠØ© ØªÙƒÙ„Ù `{ØªÙƒÙ„ÙØ©}` ØºÙŠÙ…Ø©.")
    subtract_balance(ctx.author.id, ØªÙƒÙ„ÙØ©)
    protected_users[ctx.author.id] = datetime.now() + timedelta(hours=Ø³Ø§Ø¹Ø§Øª)
    await ctx.send(f"ğŸ›¡ï¸ ØªÙ… Ø¨Ù†Ø¬Ø§Ø­ Ø´Ø±Ø§Ø¡ Ø­Ù…Ø§ÙŠØ© Ù„Ù…Ø¯Ø© **{Ø³Ø§Ø¹Ø§Øª} Ø³Ø§Ø¹Ø§Øª** Ù…Ù‚Ø§Ø¨Ù„ **{ØªÙƒÙ„ÙØ©} ØºÙŠÙ…Ø©**.")

@purchase_protection.error
async def purchase_protection_error(ctx, error):
    if isinstance(error, commands.MissingRequiredArgument):
        await ctx.send("Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø§Øª. Ù…Ø«Ø§Ù„: `!Ø´Ø±Ø§Ø¡ Ø­Ù…Ø§ÙŠØ© 5`")
    elif isinstance(error, commands.BadArgument):
        await ctx.send("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø§Øª ÙƒØ±Ù‚Ù… ØµØ­ÙŠØ­.")
    else:
        print(f"Error in purchase_protection: {error}")
        await ctx.send("Ø­Ø¯Ø« Ø®Ø·Ø£ Ù…Ø§ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø´Ø±Ø§Ø¡ Ø§Ù„Ø­Ù…Ø§ÙŠØ©.")

@bot.command()
async def Ø¨ÙŠØ¹(ctx, Ø§Ù„Ø¹Ù†ØµØ±: str, Ø§Ù„ÙƒÙ…ÙŠØ©: int = 1):
    user_id = str(ctx.author.id)
    user_items = get_items(user_id)
    found_item = next((key for key in user_items.keys() if key.lower() == Ø§Ù„Ø¹Ù†ØµØ±.lower()), None)
    if not found_item or user_items.get(found_item, 0) < Ø§Ù„ÙƒÙ…ÙŠØ©:
        return await ctx.send("Ù…Ø§ Ø¹Ù†Ø¯Ùƒ Ù‡Ø§Ù„ÙƒÙ…ÙŠØ© Ù…Ù† Ø§Ù„Ø¹Ù†ØµØ±.")
    price = int(store_items.get(found_item, 0) * 0.7) * Ø§Ù„ÙƒÙ…ÙŠØ©
    if remove_item(user_id, found_item, Ø§Ù„ÙƒÙ…ÙŠØ©):
        add_balance(user_id, price)
        await ctx.send(f"ØªÙ… Ø¨ÙŠØ¹ {Ø§Ù„ÙƒÙ…ÙŠØ©} Ù…Ù† {found_item} ÙˆÙƒØ³Ø¨Øª {price:,} ØºÙŠÙ…Ø©.")

@bot.command()
async def Ù…Ù…ØªÙ„ÙƒØ§ØªÙŠ(ctx):
    inventory = get_items(ctx.author.id)
    if not inventory:
        return await ctx.send(f"{ctx.author.mention} Ù…Ø§ Ø¹Ù†Ø¯Ùƒ Ù…Ù…ØªÙ„ÙƒØ§Øª Ø­Ø§Ù„ÙŠØ§Ù‹.")
    result = "\n".join([f"â€¢ {itm}: {qty}" for itm, qty in inventory.items()])
    await ctx.send(f"ğŸ“¦ Ù…Ù…ØªÙ„ÙƒØ§ØªÙƒ ÙŠØ§ {ctx.author.mention}:\n{result}")

@bot.command()
async def Ø§Ù‡Ø¯Ø§Ø¡(ctx, member: discord.Member, item: str):
    sender_id = str(ctx.author.id)
    user_items = get_items(sender_id)
    found_item = next((key for key in user_items.keys() if key.lower() == item.lower()), None)
    if not found_item:
        return await ctx.send("âŒ Ù…Ø§ ØªÙ…Ù„Ùƒ Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù†ØµØ±.")
    if remove_item(sender_id, found_item, 1):
        add_item(member.id, found_item, 1)
        msg = ""
        if found_item == "ÙˆØ±Ø¯Ø©":
            msg = f"ğŸ’ {ctx.author.mention} Ø£Ù‡Ø¯Ù‰ {member.mention} ÙˆØ±Ø¯Ø© Ø¬Ù…ÙŠÙ„Ø©!"
        elif found_item == "Ø¨Ø®Ø´ÙŠØ´_ÙƒØ¨ÙŠØ±":
            add_balance(member.id, 2000)
            msg = f"ğŸ’° {ctx.author.mention} Ø£Ù‡Ø¯Ù‰ {member.mention} Ø¨Ø®Ø´ÙŠØ´ ÙƒØ¨ÙŠØ±! ÙˆØªÙ…Øª Ø¥Ø¶Ø§ÙØ© 2000 ØºÙŠÙ…Ø© Ù„Ø±ØµÙŠØ¯Ù‡."
        else:
            msg = f"ğŸ {ctx.author.mention} Ø£Ù‡Ø¯Ù‰ {member.mention} {found_item}."
        await ctx.send(msg)

# ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ù…ØªØºÙŠØ± Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§
message = None

@bot.command()
async def Ø²ÙˆØ§Ø¬(ctx, Ø§Ù„Ø·Ø±Ù: discord.Member, Ø§Ù„Ù…Ù‡Ø±: int):
    global message
    if Ø§Ù„Ø·Ø±Ù.bot: return await ctx.send("ğŸ¤– ØªØ¨ÙŠ ØªØªØ²ÙˆØ¬ Ø¨ÙˆØªØŸ Ù„Ø§ ØªØ´Ø·Ø­ Ø¨Ø§Ù„Ù„Ù‡ ğŸ˜‚")
    if Ø§Ù„Ø·Ø±Ù == ctx.author: return await ctx.send("ğŸ˜ Ø´Ù‡Ø§Ù„Ø¹Ø¨Ø«ØŸ! ØªØ¨ÙŠ ØªØªØ²ÙˆØ¬ Ù†ÙØ³ÙƒØŸ Ø­Ø¨ Ø§Ù„Ø°Ø§Øª Ø´ÙŠØ¡... ÙˆØ§Ù„Ø²ÙˆØ§Ø¬ Ø´ÙŠØ¡ Ø«Ø§Ù†ÙŠ.")
    if Ø§Ù„Ù…Ù‡Ø± < 10000: return await ctx.send("ğŸ’¸ ÙŠØ§Ø¨Ø®ÙŠÙ„ Ø§Ù„Ù…Ù‡Ø± Ø£Ù‚Ù„ Ù…Ù† 10,000ØŸ ØªØ¨ÙŠÙ‡Ø§ ØªÙ‚ÙˆÙ„Ùƒ Ù†Ø¹Ù… ÙˆØ¨Ø³ØŸ ÙƒÙÙ† ÙƒØ±ÙŠÙ…!")
    if get_balance(ctx.author.id) < Ø§Ù„Ù…Ù‡Ø±: return await ctx.send(f"ğŸ’¸ Ù…Ø§ Ø¹Ù†Ø¯Ùƒ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙŠ Ù„Ø¯ÙØ¹ Ø§Ù„Ù…Ù‡Ø± ({Ø§Ù„Ù…Ù‡Ø±:,} ØºÙŠÙ…Ø©).")
    data = load_data()
    if get_user(data, ctx.author.id).get('married_to') or get_user(data, Ø§Ù„Ø·Ø±Ù.id).get('married_to'):
        return await ctx.send("âŒ Ø£Ø­Ø¯ÙƒÙ… Ù…ØªØ²ÙˆØ¬! Ø®Ù„Ùˆ Ø§Ù„Ø£Ù…ÙˆØ± ÙˆØ§Ø¶Ø­Ø© Ù‚Ø¨Ù„ Ù„Ø§ ØªÙ‚Ø¯Ù…ÙˆÙ† Ø¹Ù„Ù‰ Ø®Ø·ÙˆØ© ÙƒØ¨ÙŠØ±Ø©.")

    request_id = f"{ctx.author.id}-{Ø§Ù„Ø·Ø±Ù.id}"
    pending_marriages[request_id] = {'proposer': ctx.author, 'partner': Ø§Ù„Ø·Ø±Ù, 'mahr': Ø§Ù„Ù…Ù‡Ø±}
    
    view = discord.ui.View(timeout=60) # ØªØ¹ÙŠÙŠÙ† Ù…Ù‡Ù„Ø© 60 Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ø¹Ø±Ø¶

    # --- Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¥Ø¶Ø§ÙØ© ---
    # ØªØ¹Ø±ÙŠÙ Ø¯Ø§Ù„Ø© Ø³ÙŠØªÙ… ØªÙ†ÙÙŠØ°Ù‡Ø§ Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª
    async def on_timeout():
        # Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø·Ù„Ø¨ Ø§Ù„Ø²ÙˆØ§Ø¬ Ù„Ø§ ÙŠØ²Ø§Ù„ Ù…Ø¹Ù„Ù‚Ù‹Ø§
        if request_id in pending_marriages:
            # ØªØ¹Ø·ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
            for item in view.children:
                item.disabled = True
            # ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù„ØªØ¹ÙƒØ³ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª
            await message.edit(content="âŒ› Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª! ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ø±Ø¶ Ø§Ù„Ø²ÙˆØ§Ø¬.", view=view)
            # Ø­Ø°Ù Ø§Ù„Ø·Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©
            del pending_marriages[request_id]

    # Ø±Ø¨Ø· Ø¯Ø§Ù„Ø© Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª Ø¨Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
    view.on_timeout = on_timeout
    # --- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø¥Ø¶Ø§ÙØ© ---

    accept_button = discord.ui.Button(label="Ø£ÙˆØ§ÙÙ‚ ğŸ’", style=discord.ButtonStyle.green, custom_id=f"accept_{request_id}")
    reject_button = discord.ui.Button(label="Ø£Ø±ÙØ¶ ğŸš«", style=discord.ButtonStyle.red, custom_id=f"reject_{request_id}")

    async def button_callback(interaction: discord.Interaction):
        custom_id = interaction.data['custom_id']
        action, req_id = custom_id.split('_', 1)
        if req_id not in pending_marriages:
            # ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„ØªÙƒÙˆÙ† Ø£ÙˆØ¶Ø­ Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª
            return await interaction.response.edit_message(content="âŒ› Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª! ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ø±Ø¶ Ø§Ù„Ø²ÙˆØ§Ø¬.", view=None)
        request_data = pending_marriages[req_id]
        if interaction.user.id != request_data['partner'].id:
            return await interaction.response.send_message("Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨ Ù„ÙŠØ³ Ù„ÙƒÙ.", ephemeral=True)
        proposer, partner, mahr_amount = request_data['proposer'], request_data['partner'], request_data['mahr']
        if action == "accept":
            if get_balance(proposer.id) < mahr_amount:
                await interaction.response.edit_message(content=f"ğŸ’” ÙØ´Ù„ Ø§Ù„Ø²ÙˆØ§Ø¬. Ù„Ù… ÙŠØ¹Ø¯ Ù„Ø¯Ù‰ {proposer.mention} Ø±ØµÙŠØ¯ ÙƒØ§ÙÙ.", view=None)
            else:
                subtract_balance(proposer.id, mahr_amount)
                add_balance(partner.id, mahr_amount)
                d = load_data()
                get_user(d, proposer.id).update({'married_to': partner.id, 'mahr': mahr_amount})
                get_user(d, partner.id).update({'married_to': proposer.id, 'mahr': mahr_amount})
                save_data(d)
                await interaction.response.edit_message(content="ğŸ‰ ØªÙ… Ø§Ù„Ø²ÙˆØ§Ø¬! Ø§Ù„Ù„Ù‡ ÙŠØªÙ…Ù… Ø¹Ù„ÙŠÙƒÙ… Ø¨Ø§Ù„ÙØ±Ø­ ğŸŒ¸", view=None)
        else:
            await interaction.response.edit_message(content="ğŸ’” ØªÙ… Ø§Ù„Ø±ÙØ¶... Ø§Ù„Ø­ÙŠØ§Ø© ØªØ³ØªÙ…Ø± ğŸ™‚", view=None)
        
        # Ø­Ø°Ù Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø¹Ø¯ Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙ‡
        del pending_marriages[req_id]

    accept_button.callback = button_callback
    reject_button.callback = button_callback
    view.add_item(accept_button)
    view.add_item(reject_button)
    embed = discord.Embed(title="ğŸ’ Ø¹Ø±Ø¶ Ø²ÙˆØ§Ø¬", description=f"{Ø§Ù„Ø·Ø±Ù.mention}ØŒ Ù‡Ù„ ØªÙ‚Ø¨Ù„ÙŠÙ† Ø§Ù„Ø²ÙˆØ§Ø¬ Ù…Ù† {ctx.author.mention}ØŸ\nØ¨Ù…Ù‡Ø± Ù‚Ø¯Ø±Ù‡ **{Ø§Ù„Ù…Ù‡Ø±:,}** ğŸ’°", color=0xFFC0CB)
    
    # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙˆØªØ®Ø²ÙŠÙ†Ù‡Ø§ ÙÙŠ Ø§Ù„Ù…ØªØºÙŠØ± Ø­ØªÙ‰ Ù†ØªÙ…ÙƒÙ† Ù…Ù† ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§ Ù„Ø§Ø­Ù‚Ù‹Ø§
    message = await ctx.send(embed=embed, view=view)

@bot.command()
async def Ø·Ù„Ø§Ù‚(ctx):
    user_id = ctx.author.id
    data = load_data()
    user_data = get_user(data, user_id)
    partner_id = user_data.get('married_to')
    if not partner_id:
        return await ctx.send("ğŸš« Ù…Ø§ÙÙŠ Ø¨ÙŠÙ†ÙƒÙ… Ø²ÙˆØ§Ø¬ Ø£ØµÙ„Ø§Ù‹ØŒ ØªØ¨ØºÙ‰ ØªØ·Ù„Ù‚ Ø§Ù„Ù‡ÙˆØ§Ø¡ØŸ ğŸ˜")
    partner_member = await bot.fetch_user(partner_id)
    partner_data = get_user(data, partner_id)
    user_data.update({'married_to': None, 'mahr': 0})
    partner_data.update({'married_to': None, 'mahr': 0})
    save_data(data)
    embed = discord.Embed(title="ğŸ’” ØªÙ… Ø§Ù„Ø·Ù„Ø§Ù‚", description=f"{ctx.author.mention} Ø·Ù„Ù‘Ù‚ {partner_member.mention}...\nØ§Ù„Ù‚Ù„ÙˆØ¨ Ù…Ø§ Ø¨Ù‚Øª Ø¹Ù„Ù‰ Ø­Ø§Ù„Ù‡Ø§ØŒ ÙˆØ§Ù„Ø­ÙŠØ§Ø© ØªØ³ØªÙ…Ø±. ğŸ¥€", color=0x8B0000)
    await ctx.send(embed=embed)

@bot.command()
async def Ø®Ù„Ø¹(ctx):
    user_id = ctx.author.id
    data = load_data()
    user_data = get_user(data, user_id)
    partner_id = user_data.get('married_to')
    mahr = user_data.get('mahr', 0)

    if not partner_id:
        return await ctx.send("ğŸš« ÙˆØ´ ØªØ®Ù„Ø¹ÙŠÙ†ØŸ Ù„Ø§ ÙÙŠ Ø²ÙˆØ§Ø¬ ÙˆÙ„Ø§ ÙÙŠ Ù…Ø­ÙƒÙ…Ø© Ù‡Ù†Ø§ ğŸ˜‚")

    Ù†ØµÙ_Ø§Ù„Ù…Ù‡Ø± = int(mahr * 0.5)
    if get_balance(user_id) < Ù†ØµÙ_Ø§Ù„Ù…Ù‡Ø±:
        return await ctx.send(f"ğŸ˜“ Ù…Ø¹Ù„ÙŠØ´ØŒ Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Ù…Ø¹Ùƒ {Ù†ØµÙ_Ø§Ù„Ù…Ù‡Ø±:,} ØºÙŠÙ…Ø© Ø¹Ø´Ø§Ù† ØªØ¯ÙØ¹ÙŠ Ù†Øµ Ø§Ù„Ù…Ù‡Ø± ÙˆØªØ®Ù„Ø¹ÙŠÙ†Ù‡.")

    # 1) ØªØ³Ø­Ø¨ Ù†Øµ Ø§Ù„Ù…Ù‡Ø± Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù„ÙŠ ÙŠØ®Ù„Ø¹
    subtract_balance(user_id, Ù†ØµÙ_Ø§Ù„Ù…Ù‡Ø±)
    # 2) ØªØ±Ø¬Ø¹ Ù†Øµ Ø§Ù„Ù…Ù‡Ø± Ù„Ù„Ø´Ø±ÙŠÙƒ
    add_balance(partner_id, Ù†ØµÙ_Ø§Ù„Ù…Ù‡Ø±)

    # 3) Ø­Ø¯Ø« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø²ÙˆØ§Ø¬ Ø¹Ù†Ø¯ Ø§Ù„Ø·Ø±ÙÙŠÙ†
    user_data['married_to'] = None
    user_data['mahr'] = 0
    partner_data = get_user(data, partner_id)
    partner_data['married_to'] = None
    partner_data['mahr'] = 0

    save_data(data)

    # 4) Ø¬Ù‡Ø² Ø§Ù„Ù€Embed Ø¨Ø¹Ø¯ Ù…Ø§ Ø®Ø²Ù†Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    partner_member = await bot.fetch_user(partner_id)
    embed = discord.Embed(
        title="ğŸ¥€ ØªÙ… Ø§Ù„Ø®ÙÙ„Ø¹",
        description=(
            f"{ctx.author.mention} Ø®Ù„Ø¹Øª {partner_member.mention} Ø¨Ø¹Ø¯ Ù…Ø§ Ø¯ÙØ¹Øª "
            f"{Ù†ØµÙ_Ø§Ù„Ù…Ù‡Ø±:,} ØºÙŠÙ…Ø© Ù†Øµ Ø§Ù„Ù…Ù‡Ø±ØŒ ÙˆØ±ÙØ¬Ø¹ Ø§Ù„Ù…Ø¨Ù„Øº Ù„ØµØ§Ø­Ø¨ Ø§Ù„Ø­Ù‚."
        ),
        color=0xB22222
    )
    await ctx.send(embed=embed)

@bot.command(name="Ù‚Ø§Ø¦Ù…Ø©_Ø§Ù„Ø²ÙˆØ§Ø¬", aliases=["Ø§Ù„Ø²ÙˆØ§Ø¬Ø§Øª", "Ù‚Ø§Ø¦Ù…Ø©_Ø§Ù„Ø²ÙŠØ¬Ø§Øª"])
async def marriage_list(ctx):
    data = load_data()
    
    marriages = []
    processed_users = set()

    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø²ÙˆØ§Ø¬ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    # Ù†ÙØªØ±Ø¶ Ø£Ù† data Ù‡Ùˆ Ù‚Ø§Ù…ÙˆØ³ Ù…Ø«Ù„ {'user_id': {'married_to': partner_id, 'mahr': amount}}
    for user_id_str, user_data in data.items():
        user_id = int(user_id_str)
        
        # Ù†ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù… ØªØªÙ… Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡ Ù…Ù† Ù‚Ø¨Ù„ ÙˆØ£Ù†Ù‡ Ù…ØªØ²ÙˆØ¬
        if user_id in processed_users or not user_data.get('married_to'):
            continue

        partner_id = user_data.get('married_to')
        mahr = user_data.get('mahr', 0)  # Ù†Ø¶Ø¹ Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© 0 Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

        # Ù†Ø¶ÙŠÙ Ø§Ù„Ø²ÙˆØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        marriages.append({
            "couple": (user_id, partner_id),
            "mahr": mahr
        })

        # Ù†Ø¶ÙŠÙ ÙƒÙ„Ø§ Ø§Ù„Ø²ÙˆØ¬ÙŠÙ† Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† ØªÙ…Ù‘Øª Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ù… Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
        processed_users.add(user_id)
        processed_users.add(partner_id)

    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ø²ÙŠØ¬Ø§Øª Ù„Ø¹Ø±Ø¶Ù‡Ø§
    if not marriages:
        return await ctx.send("ğŸ’” Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙŠ Ø²ÙŠØ¬Ø§Øª Ø­Ø§Ù„ÙŠÙ‹Ø§ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±.")

    # ØªØ±ØªÙŠØ¨ Ø§Ù„Ø²ÙŠØ¬Ø§Øª Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰ Ù…Ù‡Ø±Ù‹Ø§ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„
    sorted_marriages = sorted(marriages, key=lambda m: m['mahr'], reverse=True)

    # ØªØ¬Ù‡ÙŠØ² Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¹Ø±Ø¶ (Embed)
    embed = discord.Embed(
        title="ğŸ’ Ù‚Ø§Ø¦Ù…Ø© Ø£ØºÙ„Ù‰ Ø§Ù„Ø²ÙŠØ¬Ø§Øª ğŸ’",
        description="Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø²ÙŠØ¬Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ø±ØªØ¨Ø© Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰ Ù…Ù‡Ø±Ù‹Ø§ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„:",
        color=discord.Color.gold()
    )

    description_text = ""
    # Ø§Ù‚ØªØµØ§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¹Ù„Ù‰ Ø£ÙˆÙ„ 20 Ø²ÙˆØ§Ø¬Ù‹Ø§ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ù‹Ø§
    for index, marriage in enumerate(sorted_marriages[:20], 1):
        try:
            user1 = await bot.fetch_user(marriage['couple'][0])
            user2 = await bot.fetch_user(marriage['couple'][1])
            mahr_formatted = f"{marriage['mahr']:,}"
            
            description_text += f"**{index}.** {user1.mention} â¤ï¸ {user2.mention}\n"
            description_text += f"> **Ø§Ù„Ù…Ù‡Ø±:** {mahr_formatted} ğŸ’°\n\n"
        except discord.NotFound:
            # ÙÙŠ Ø­Ø§Ù„ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (ØºØ§Ø¯Ø± Ø§Ù„Ø³ÙŠØ±ÙØ± Ù…Ø«Ù„Ø§Ù‹)
            continue
    
    if not description_text:
        return await ctx.send("ğŸ’” Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙŠ Ø²ÙŠØ¬Ø§Øª Ø­Ø§Ù„ÙŠÙ‹Ø§ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±.")

    embed.description = description_text
    embed.set_footer(text=f"Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø§Ù„Ø²ÙŠØ¬Ø§Øª: {len(sorted_marriages)}")

    await ctx.send(embed=embed)

@bot.command()
async def ÙˆÙ‚Øª(ctx):
    Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ = []
    for command in bot.commands:
        if command.is_on_cooldown(ctx):
            retry_after = command.get_cooldown_retry_after(ctx)
            Ø¯Ù‚Ø§Ø¦Ù‚, Ø«ÙˆØ§Ù†ÙŠ = divmod(int(retry_after), 60)
            Ø§Ù„Ø±Ø³Ø§Ø¦Ù„.append(f"â€¢ `{command.name}`: Ø¨Ø§Ù‚ÙŠ {Ø¯Ù‚Ø§Ø¦Ù‚} Ø¯Ù‚ÙŠÙ‚Ø© Ùˆ {Ø«ÙˆØ§Ù†ÙŠ} Ø«Ø§Ù†ÙŠØ©")
    if not Ø§Ù„Ø±Ø³Ø§Ø¦Ù„:
        await ctx.send("âœ… Ø¬Ù…ÙŠØ¹ Ø£ÙˆØ§Ù…Ø±Ùƒ Ù…ØªØ§Ø­Ø© Ø§Ù„Ø¢Ù†!")
    else:
        await ctx.send("â³ Ù‡Ø°Ù‡ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ù…Ø§ Ø²Ø§Ù„Øª Ø¹Ù„Ù‰ ÙƒÙˆÙ„Ø¯Ø§ÙˆÙ†:\n" + "\n".join(Ø§Ù„Ø±Ø³Ø§Ø¦Ù„))

@bot.command(name="Ø£ÙˆØ§Ù…Ø±ÙŠ")
@commands.has_role(GHAIM_ROLE_ID)
async def admin_commands(ctx):
    await ctx.send(f"""âœ¨ Ø§ÙˆØ§Ù…Ø± Ù…Ø§Ù„ÙƒØ© Ø§Ù„Ø¨ÙˆØª âœ¨:

ğŸ” !Ù…Ù†Ø¹ [Ù…Ù†Ø´Ù†] â€” ÙŠÙ…Ù†Ø¹ Ø´Ø®Øµ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª.
ğŸ”“ !ÙÙƒ_Ø§Ù„Ù…Ù†Ø¹ [Ù…Ù†Ø´Ù†] â€” ÙŠÙÙƒ Ø§Ù„Ù…Ù†Ø¹ Ø¹Ù† Ø§Ù„Ø´Ø®Øµ.
ğŸ’¸ !ØªØµÙÙŠØ± [Ù…Ù†Ø´Ù†] â€” ÙŠØµÙØ± Ø±ØµÙŠØ¯ Ø´Ø®Øµ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„.
ğŸ !Ø¥Ø¹Ø·Ø§Ø¡ [Ù…Ù†Ø´Ù†] [Ù…Ø¨Ù„Øº] â€” ÙŠØ¹Ø·ÙŠ Ø´Ø®Øµ Ù…Ø¨Ù„Øº Ù…Ø¹ÙŠÙ‘Ù†.
ğŸ“œ !Ø³Ø¬Ù„ â€” ÙŠØ¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù„ÙŠ Ø³ÙˆÙŠØªÙŠÙ‡Ø§ Ø¨ØµÙ„Ø§Ø­ÙŠØ§ØªÙƒ.
ğŸ§¹ !ØªÙ†Ø¸ÙŠÙ [Ø¹Ø¯Ø¯] â€” ÙŠØ­Ø°Ù Ø¹Ø¯Ø¯ Ù…Ù† Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø´Ø§Øª (Ø­ØªÙ‰ 100).
""")

@bot.command()
@commands.has_role(GHAIM_ROLE_ID)
async def Ù…Ù†Ø¹(ctx, member: discord.Member):
    banned_users.add(member.id)
    await ctx.send(f"ğŸš« ØªÙ… Ù…Ù†Ø¹ {member.mention} Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª.")

@bot.command()
@commands.has_role(GHAIM_ROLE_ID)
async def ÙÙƒ_Ø§Ù„Ù…Ù†Ø¹(ctx, member: discord.Member):
    if member.id not in banned_users:
        await ctx.send(f"â„¹ï¸ {member.mention} ÙŠØ¨Ø¯Ùˆ Ø§Ù†Ùƒ Ø­Ø§ÙˆÙ„ØªÙ Ø§Ù„Ø¹ÙÙˆ Ø¹Ù† Ø´Ø®ØµÙ Ù„ÙŠØ³ Ø¨Ù…Ø¬Ø±Ù….")
    else:
        banned_users.remove(member.id)
        await ctx.send(f"Ù„Ø¹Ù„Ùƒ ÙÙ‡Ù…Øª Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„Ø¢Ù† {member.mention} ğŸ’­ \n Ø§Ù„ØºÙŠÙ…Ø© Ø³Ø§Ù…Ø­ØªÙƒØŒ Ù„ÙƒÙ† Ù„Ø§ ØªØ®ØªØ¨Ø±ÙŠ ØµØ¨Ø±Ù‡Ø§ Ù…Ø¬Ø¯Ø¯Ù‹Ø§ â˜ï¸ \n ØªÙ… ÙÙƒ Ø§Ù„Ù…Ù†Ø¹ØŒ Ø§Ø±Ø¬Ø¹ÙŠ Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¨Ù„Ø·Ù")

@bot.command()
@commands.has_role(GHAIM_ROLE_ID)
async def ØªØµÙÙŠØ±(ctx, member: discord.Member):
    set_balance(member.id, 0)
    await ctx.send(f"âœ… ØªÙ… ØªØµÙÙŠØ± Ø±ØµÙŠØ¯ {member.mention}.")

@commands.has_role(GHAIM_ROLE_ID)
@bot.command(name="Ø§Ø¹Ø·Ø§Ø¡")
async def Ø§Ø¹Ø·Ø§Ø¡(ctx, member: discord.Member, amount: int):
    if amount <= 0:
        return await ctx.send("ğŸ”º ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ø¨Ù„Øº Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±.")
    add_balance(member.id, amount)
    await ctx.send(
        f"ğŸ’° ØªÙ… Ø¥Ø¶Ø§ÙØ© {amount:,} ØºÙŠÙ…Ø© Ø¥Ù„Ù‰ Ø±ØµÙŠØ¯ {member.mention}. "
        f"Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø¢Ù†: {get_balance(member.id):,} ØºÙŠÙ…Ø§Øª."
    )
@Ø§Ø¹Ø·Ø§Ø¡.error
async def Ø§Ø¹Ø·Ø§Ø¡_error(ctx, error):
    if isinstance(error, commands.MissingRole):
        await ctx.send("âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø£Ù†ØªÙ Ù„Ø§ ØªÙ…Ù„ÙƒÙŠÙ† Ø¯ÙˆØ± Ø§Ù„Ù…Ø§Ù„ÙƒØ© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±.")
    elif isinstance(error, commands.BadArgument):
        await ctx.send("âŒ ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…Ù†Ø´Ù† Ø§Ù„ØµØ­ÙŠØ­ Ù„Ù„Ø¹Ø¶Ùˆ ÙˆÙƒØªØ§Ø¨Ø© Ø§Ù„Ù…Ø¨Ù„Øº ÙƒØ±Ù‚Ù… ØµØ­ÙŠØ­.")
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send("âŒ ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ø¶Ùˆ ÙˆØ§Ù„Ù…Ø¨Ù„Øº: `!Ø§Ø¹Ø·Ø§Ø¡ @Ø¹Ø¶Ùˆ 1000`")
    else:
        # Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„ Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ Ø§Ù„Ù€ debugging
        print(f"Error in Ø§Ø¹Ø·Ø§Ø¡ command: {error}")
        await ctx.send("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.")


@bot.command()
@commands.has_role(GHAIM_ROLE_ID)
async def ØªÙ†Ø¸ÙŠÙ(ctx, limit: int):
    if limit > 100:
        await ctx.send("ğŸš« Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„ØªÙ†Ø¸ÙŠÙ 100 Ø±Ø³Ø§Ù„Ø©.")
        limit = 100
    deleted = await ctx.channel.purge(limit=limit)
    await ctx.send(f"ğŸ§¹ ØªÙ… Ø­Ø°Ù {len(deleted)} Ø±Ø³Ø§Ù„Ø©.", delete_after=5)

@bot.command()
@commands.has_role(GHAIM_ROLE_ID)
async def Ø³Ø¬Ù„(ctx, member: discord.Member = None):
    logs = load_log()
    if member:
        filtered_logs = [log for log in logs if log.get("target") == str(member.id)]
        if not filtered_logs: return await ctx.send(f"ğŸ“­ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø³Ø¬Ù„ Ù„Ù„Ø¹Ø¶ÙˆØ© {member.mention}.")
    else:
        filtered_logs = [log for log in logs if log.get("executor") == str(ctx.author.id)]
        if not filtered_logs: return await ctx.send("ğŸ“­ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø³Ø¬Ù„ Ù„Ø¹Ù…Ù„ÙŠØ§ØªÙƒ.")
    embed = discord.Embed(title=f"ğŸ“œ Ø³Ø¬Ù„ {'Ø§Ù„Ø¹Ø¶ÙˆØ© ' + member.name if member else 'Ø£ÙˆØ§Ù…Ø±Ùƒ'}", color=0x8ECDFE)
    for log in reversed(filtered_logs[-10:]):
        try: target_user = await bot.fetch_user(int(log['target']))
        except: target_user = None
        target_mention = target_user.mention if target_user else f"ID: {log['target']}"
        embed.add_field(name=f"ğŸ”§ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: {log['action']}", value=f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ©: {target_mention}\nâ° Ø§Ù„ÙˆÙ‚Øª: {log['time']}", inline=False)
    await ctx.send(embed=embed)

@bot.command()
async def Ø§ÙˆØ§Ù…Ø±(ctx):
    embed = discord.Embed(title="ğŸŒ€ Ø£ÙˆØ§Ù…Ø± Ø¨ÙˆØª ØºÙŠÙ…", description="Ù‡Ø°ÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø¨ÙˆØª ğŸŒ§ï¸âœ¨", color=0x87ceeb)
    embed.add_field(name="ğŸ’¸ Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØºÙŠÙ…Ø§Øª:", value="`!Ø±Ø§ØªØ¨`, `!Ø¨Ø®Ø´ÙŠØ´`, `!Ø±ÙˆÙ„ÙŠØª`, `!ØªØ¯Ø§ÙˆÙ„`, `!Ø§Ø³ØªØ«Ù…Ø§Ø±`, `!ØªØ­ÙˆÙŠÙ„`, `!Ø§Ù‡Ø¯Ø§Ø¡`, `!Ù†Ù‡Ø¨`, `!Ø±ØµÙŠØ¯ÙŠ`, `!ØªÙˆØ¨`", inline=False)
    embed.add_field(name="ğŸ“ˆ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØ±ØµØ©:", value="`!Ø¨ÙˆØ±ØµØ©`, `!Ø³Ø¹Ø±_Ø³Ù‡Ù…`, `!Ø´Ø±Ø§Ø¡_Ø³Ù‡Ù…`, `!Ø¨ÙŠØ¹_Ø³Ù‡Ù…`, `!Ù…Ø­ÙØ¸ØªÙŠ`", inline=False)
    embed.add_field(name="ğŸ›ï¸ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ¬Ø±:", value="`!Ù…ØªØ¬Ø±`, `!Ø´Ø±Ø§Ø¡`, `!Ø¨ÙŠØ¹`, `!Ù…Ù…ØªÙ„ÙƒØ§ØªÙŠ`", inline=False)
    embed.add_field(name="ğŸ² Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ø¨ÙˆØª:", value="`!ÙƒÙ†Ø²` ,`!Ø³Ù„ÙˆØª` ,`!Ù„Ø¹Ø¨Ø©`", inline=False)
    embed.add_field(
    name="ğŸ’ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø²ÙˆØ§Ø¬:", 
    value="`!Ø²ÙˆØ§Ø¬`, `!Ø·Ù„Ø§Ù‚`, `!Ø®Ù„Ø¹`\n"
          "`!Ù‚Ø§Ø¦Ù…Ø©_Ø§Ù„Ø²ÙˆØ§Ø¬` - Ù„Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ø²ÙŠØ¬Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©.\n"
          "*(ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ø§Ù‹ Ø§Ø³ØªØ®Ø¯Ø§Ù… `!Ø§Ù„Ø²ÙˆØ§Ø¬Ø§Øª` Ø£Ùˆ `!Ù‚Ø§Ø¦Ù…Ø©_Ø§Ù„Ø²ÙŠØ¬Ø§Øª`)*", 
    inline=False
)
    embed.add_field(name="â±ï¸ Ø£ÙˆØ§Ù…Ø± Ø®Ø¯Ù…ÙŠØ©:", value="`!ÙˆÙ‚Øª`", inline=False)
    embed.set_footer(text="Ø¨ÙˆØª ØºÙŠÙ… - Ù„Ø£Ø¬Ù„ Ø§Ù„Ù…ØªØ¹Ø© ÙˆØ§Ù„Ø£Ø³Ø±Ø§Ø± â˜ï¸")
    await ctx.send(embed=embed)

# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„Ø¹Ø¨Ø© Ø§Ù„Ø³Ù„ÙˆØª ---
ROWS = 3
COLS = 3
WIN_AMOUNT = 1000   # Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· (Ø§Ù„ØºÙŠÙ…Ø§Øª) Ø§Ù„ØªÙŠ ÙŠØ±Ø¨Ø­Ù‡Ø§ Ø¹Ù†Ø¯ ØªØ·Ø§Ø¨Ù‚ ØµÙ
SPIN_COUNT = 3      # Ø¹Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±Ø§Øª ÙÙŠ ÙƒÙ„ Ù…Ø±Ø© ÙŠØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£Ù…Ø±
EMOJIS = ["ğŸ’", "ğŸŠ", "ğŸ‰", "â­", "ğŸ’", "ğŸ””"]

def spin_one_round():
    """ÙŠÙ†Ø´Ø¦ Ø´Ø¨ÙƒØ© Ø³Ù„ÙˆØª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù„Ø¯ÙˆØ±Ø© ÙˆØ§Ø­Ø¯Ø©."""
    return [[random.choice(EMOJIS) for _ in range(COLS)] for _ in range(ROWS)]

def check_for_win(grid):
    """ØªØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø£ÙŠ ØµÙ Ù…ØªØ·Ø§Ø¨Ù‚."""
    return any(len(set(row)) == 1 for row in grid)

@bot.command(name="Ø³Ù„ÙˆØª")
@commands.cooldown(1, DEFAULT_COOLDOWN, commands.BucketType.user)
async def play_slot(ctx):
    """
    ØªØ´ØºÙ‘Ù„ Ù„Ø¹Ø¨Ø© Ø§Ù„Ø³Ù„ÙˆØª Ø«Ù„Ø§Ø« Ø¯ÙˆØ±Ø§ØªØŒ ÙˆØªÙƒØ§ÙØ¦ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¨Ù€ WIN_AMOUNT ØºÙŠÙ…Ø© Ù„ÙƒÙ„ Ø¯ÙˆØ±Ø© Ø±Ø§Ø¨Ø­Ø©.
    """
    user_id = ctx.author.id
    total_winnings = 0

    await ctx.send(f"ğŸ° **Ù„Ø¹Ø¨Ø© Ø§Ù„Ø³Ù„ÙˆØª** ØªØ¨Ø¯Ø£ Ø§Ù„Ø¢Ù†! Ù„Ø¯ÙŠÙƒ {SPIN_COUNT} Ø¯ÙˆØ±Ø§Øª. Ø­Ø¸Ù‹Ø§ Ø³Ø¹ÙŠØ¯Ù‹Ø§! ğŸ€")

    for i in range(1, SPIN_COUNT+1):
        grid = spin_one_round()
        # Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø´Ø¨ÙƒØ©
        rows_str = "\n".join(" | ".join(row) for row in grid)
        await ctx.send(f"**Ø§Ù„Ø¯ÙˆØ±Ø© {i}/{SPIN_COUNT}:**\n{rows_str}")

        if check_for_win(grid):
            total_winnings += WIN_AMOUNT
            await ctx.send(f"âœ¨ Ù…Ø¨Ø±ÙˆÙƒ! Ø±Ø¨Ø­Øª **{WIN_AMOUNT}** ØºÙŠÙ…Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¯ÙˆØ±Ø©!")

        else:
            await ctx.send("ğŸ˜¢ Ù„Ù… ØªÙØ² ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¯ÙˆØ±Ø©.")

        # ÙØ§ØµÙ„ Ø¨Ø³ÙŠØ· Ø¨ÙŠÙ† Ø§Ù„Ø¯ÙˆØ±Ø§Øª
        await asyncio.sleep(1)

    if total_winnings > 0:
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        add_balance(user_id, total_winnings)
        new_balance = get_balance(user_id)
        await ctx.send(f"\nğŸ‰ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! Ø±Ø¨Ø­Ùƒ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ **{total_winnings}** ØºÙŠÙ…Ø©. Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø¢Ù†: **{new_balance}** ØºÙŠÙ…Ø©.")
    else:
        await ctx.send("\nâ˜ï¸ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆÙ„Ù… ØªØ±Ø¨Ø­ Ø´ÙŠØ¦Ù‹Ø§ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§!")

# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ†Ø² ---
TREASURE_EMOJI = "ğŸ’"
BOMB_EMOJI     = "ğŸ’£"
EMPTY_EMOJI    = "â¬œ"
HIDDEN_EMOJI   = "ğŸ“¦"
WIN_REWARD     = 1000
BALANCE_FILE   = "clouds_balance.json"

def load_balances():
    if os.path.exists(BALANCE_FILE):
        with open(BALANCE_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_balances(balances):
    with open(BALANCE_FILE, 'w') as f:
        json.dump(balances, f, ensure_ascii=False, indent=4)

class TreasureHuntView(View):
    def __init__(self, author):
        super().__init__(timeout=180.0)
        self.author = author
        self.board = self._generate_board()
        self.treasures_found = 0
        self.game_over = False
        self._add_buttons()

    def _generate_board(self):
        items = [TREASURE_EMOJI]*3 + [BOMB_EMOJI]*1 + [EMPTY_EMOJI]*5
        random.shuffle(items)
        return [items[i:i+3] for i in range(0, 9, 3)]

    def _add_buttons(self):
        for r in range(3):
            for c in range(3):
                btn = Button(label=HIDDEN_EMOJI, style=discord.ButtonStyle.secondary, custom_id=f"{r}_{c}")
                btn.callback = self.button_callback
                self.add_item(btn)

    async def interaction_check(self, interaction):
        if interaction.user.id != self.author.id:
            await interaction.response.send_message("Ù‡Ø°Ù‡ Ù„ÙŠØ³Øª Ù„Ø¹Ø¨ØªÙƒ!", ephemeral=True)
            return False
        return True

    async def button_callback(self, interaction):
        if self.game_over:
            return await interaction.response.defer()

        r, c = map(int, interaction.data['custom_id'].split('_'))
        btn = next(b for b in self.children if b.custom_id == f"{r}_{c}")
        revealed = self.board[r][c]
        btn.emoji   = revealed
        btn.disabled = True

        embed = interaction.message.embeds[0]

        if revealed == BOMB_EMOJI:
            self.game_over = True
            btn.style = discord.ButtonStyle.danger
            embed.title = "ğŸ’¥ Ù„Ù‚Ø¯ Ø§Ù†ÙØ¬Ø±Øª Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©! ğŸ’¥"
            embed.description = "Ø­Ø¸ Ø£ÙˆÙØ± ÙÙŠ Ø§Ù„Ù…Ø±Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©!"
            embed.color = discord.Color.red()
            await self.disable_all_buttons(interaction)

        elif revealed == TREASURE_EMOJI:
            self.treasures_found += 1
            btn.style = discord.ButtonStyle.success
            embed.description = f"ÙƒÙ†ÙˆØ² ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„ÙŠÙ‡Ø§: {self.treasures_found}/3"

            if self.treasures_found == 3:
                self.game_over = True
                embed.title = "ğŸ‰ Ù„Ù‚Ø¯ ÙˆØ¬Ø¯Øª ÙƒÙ„ Ø§Ù„ÙƒÙ†ÙˆØ²! ğŸ‰"
                embed.description = f"Ù„Ù‚Ø¯ ÙØ²Øª Ø¨Ù€ {WIN_REWARD} ØºÙŠÙ…Ø©! â˜ï¸"
                embed.color = discord.Color.gold()
                # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµÙŠØ¯
                bals = load_balances()
                uid = str(self.author.id)
                bals[uid] = bals.get(uid, 0) + WIN_REWARD
                save_balances(bals)
                await self.disable_all_buttons(interaction)

        else:
            btn.style = discord.ButtonStyle.primary

        await interaction.response.edit_message(embed=embed, view=self)

    async def disable_all_buttons(self, interaction):
        for item in self.children:
            item.disabled = True
        await interaction.message.edit(view=self)

@bot.command(name="ÙƒÙ†Ø²")
async def treasure_hunt(ctx):
    """Ø§Ø¨Ø¯Ø£ Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ†Ø²."""
    embed = discord.Embed(
        title="ğŸ´â€â˜ ï¸ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ†Ø² ğŸ´â€â˜ ï¸",
        description="Ø§Ø¨Ø­Ø« Ø¹Ù† 3 ÙƒÙ†ÙˆØ² ğŸ’ ÙˆØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© ğŸ’£!\nÙƒÙ†ÙˆØ² ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„ÙŠÙ‡Ø§: 0/3",
        color=discord.Color.blue()
    )
    embed.set_footer(text=f"Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø¯Ø£Øª Ø¨ÙˆØ§Ø³Ø·Ø©: {ctx.author.display_name}")
    await ctx.send(embed=embed, view=TreasureHuntView(ctx.author))

# @bot.command(name="Ø±ØµÙŠØ¯ÙŠ")
# async def balance(ctx):
#     """Ø¹Ø±Ø¶ Ø±ØµÙŠØ¯ Ø§Ù„ØºÙŠÙ…Ø§Øª."""
#     bals = load_balances()
#     user_balance = bals.get(str(ctx.author.id), 0)
#     await ctx.send(f"{ctx.author.mention}ØŒ Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù‡Ùˆ: {user_balance} ØºÙŠÙ…Ø© â˜ï¸")

# --- The rest of the commands (store, marriage, admin, etc.) are unchanged ---

# =============================================================================
# RUN THE BOT
# =============================================================================
# Ø§Ø³ØªØ¨Ø¯Ù„ Ø§Ù„Ù†Øµ Ø§Ù„ØªØ§Ù„ÙŠ Ø¨Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ø¨ÙˆØª
btoken = os.getenv("DISCORD_TOKEN")
